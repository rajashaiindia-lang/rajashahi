{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 74, "column": 0}, "map": {"version":3,"sources":["file:///home/hardik/rajashai/lib/mongodb.ts"],"sourcesContent":["import mongoose from 'mongoose';\n\nconst MONGODB_URI = process.env.MONGODB_URI as string;\nif (!MONGODB_URI) {\n  throw new Error(\"MONGODB_URI is not set\");\n}\n\n// Global cache to survive hot-reloads in dev\ndeclare global {\n  // eslint-disable-next-line no-var\n  var _mongoose: { conn: typeof mongoose | null, promise: Promise<typeof mongoose> | null } | undefined;\n}\n\nlet cached = global._mongoose;\nif (!cached) cached = global._mongoose = { conn: null, promise: null };\n\nexport async function dbConnect() {\n  if (cached!.conn) return cached!.conn;\n\n  if (!cached!.promise) {\n    cached!.promise = mongoose.connect(MONGODB_URI).then((m) => m);\n  }\n  cached!.conn = await cached!.promise;\n  return cached!.conn;\n}\n"],"names":[],"mappings":";;;AAAA;;AAEA,MAAM,cAAc,QAAQ,GAAG,CAAC,WAAW;AAC3C,IAAI,CAAC,aAAa;IAChB,MAAM,IAAI,MAAM;AAClB;AAQA,IAAI,SAAS,OAAO,SAAS;AAC7B,IAAI,CAAC,QAAQ,SAAS,OAAO,SAAS,GAAG;IAAE,MAAM;IAAM,SAAS;AAAK;AAE9D,eAAe;IACpB,IAAI,OAAQ,IAAI,EAAE,OAAO,OAAQ,IAAI;IAErC,IAAI,CAAC,OAAQ,OAAO,EAAE;QACpB,OAAQ,OAAO,GAAG,yGAAA,CAAA,UAAQ,CAAC,OAAO,CAAC,aAAa,IAAI,CAAC,CAAC,IAAM;IAC9D;IACA,OAAQ,IAAI,GAAG,MAAM,OAAQ,OAAO;IACpC,OAAO,OAAQ,IAAI;AACrB","debugId":null}},
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["file:///home/hardik/rajashai/models/Round.ts"],"sourcesContent":["// models/Round.ts\nimport { Schema, Document, models, model } from 'mongoose';\n\nexport type Market = 'KALYAN';\nexport type RoundStatus = 'READY' | 'OPENING_PUBLISHED' | 'CLOSED';\n\n/** Plain shape (what .lean() returns) */\nexport interface RoundCore {\n  roundId: string;               // unique, timestamp-based or your generator\n  sessionDate: string;           // 'YYYY-MM-DD' (local session date)\n  market: Market;                // 'KALYAN' | 'DEMO' (extend later if needed)\n  openingTime: string;           // 'HH:mm' (local publish time)\n  closingTime: string;           // 'HH:mm'\n\n  // Opening side\n  openingPanna?: string;         // '000'..'999'\n  openingDigit?: number;         // 0..9 (derived from openingPanna)\n\n  // Closing side\n  closingPanna?: string;         // '000'..'999'\n  closingDigit?: number;         // 0..9 (derived from closingPanna)\n\n  // Derived convenience\n  jodi?: string;                 // '00'..'99' = `${openingDigit}${closingDigit}`\n\n  status: RoundStatus;\n\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n/** Mongoose document shape (when not using .lean()) */\nexport interface IRound extends Document, RoundCore {}\n\nconst timeHHmm = /^([01]\\d|2[0-3]):[0-5]\\d$/;\nconst panna3 = /^\\d{3}$/;\nconst jodi2 = /^\\d{2}$/;\n\nconst RoundSchema = new Schema<IRound>({\n  roundId: { type: String, required: true, unique: true },\n\n  sessionDate: {\n    type: String,\n    required: true,                     // e.g., '2025-10-01'\n    match: /^\\d{4}-\\d{2}-\\d{2}$/\n  },\n  market: {\n    type: String,\n  default: 'KALYAN',\n    required: true\n  },\n\n  openingTime: { type: String, required: true, match: timeHHmm },\n  closingTime: { type: String, required: true, match: timeHHmm },\n\n  openingPanna: { type: String, match: panna3, default: undefined },\n  openingDigit: { type: Number, min: 0, max: 9, default: undefined },\n\n  closingPanna: { type: String, match: panna3, default: undefined },\n  closingDigit: { type: Number, min: 0, max: 9, default: undefined },\n\n  jodi: { type: String, match: jodi2, default: undefined },\n\n  status: {\n    type: String,\n    enum: ['READY', 'OPENING_PUBLISHED', 'CLOSED'],\n    default: 'READY',\n    required: true\n  }\n}, { timestamps: true });\n\n// Helpful unique constraint to avoid duplicate market-day sessions:\nRoundSchema.index({ market: 1, sessionDate: 1 }, { unique: true });\n\nexport default models.Round || model<IRound>('Round', RoundSchema);\n"],"names":[],"mappings":"AAAA,kBAAkB;;;;AAClB;;AAiCA,MAAM,WAAW;AACjB,MAAM,SAAS;AACf,MAAM,QAAQ;AAEd,MAAM,cAAc,IAAI,yGAAA,CAAA,SAAM,CAAS;IACrC,SAAS;QAAE,MAAM;QAAQ,UAAU;QAAM,QAAQ;IAAK;IAEtD,aAAa;QACX,MAAM;QACN,UAAU;QACV,OAAO;IACT;IACA,QAAQ;QACN,MAAM;QACR,SAAS;QACP,UAAU;IACZ;IAEA,aAAa;QAAE,MAAM;QAAQ,UAAU;QAAM,OAAO;IAAS;IAC7D,aAAa;QAAE,MAAM;QAAQ,UAAU;QAAM,OAAO;IAAS;IAE7D,cAAc;QAAE,MAAM;QAAQ,OAAO;QAAQ,SAAS;IAAU;IAChE,cAAc;QAAE,MAAM;QAAQ,KAAK;QAAG,KAAK;QAAG,SAAS;IAAU;IAEjE,cAAc;QAAE,MAAM;QAAQ,OAAO;QAAQ,SAAS;IAAU;IAChE,cAAc;QAAE,MAAM;QAAQ,KAAK;QAAG,KAAK;QAAG,SAAS;IAAU;IAEjE,MAAM;QAAE,MAAM;QAAQ,OAAO;QAAO,SAAS;IAAU;IAEvD,QAAQ;QACN,MAAM;QACN,MAAM;YAAC;YAAS;YAAqB;SAAS;QAC9C,SAAS;QACT,UAAU;IACZ;AACF,GAAG;IAAE,YAAY;AAAK;AAEtB,oEAAoE;AACpE,YAAY,KAAK,CAAC;IAAE,QAAQ;IAAG,aAAa;AAAE,GAAG;IAAE,QAAQ;AAAK;uCAEjD,yGAAA,CAAA,SAAM,CAAC,KAAK,IAAI,CAAA,GAAA,yGAAA,CAAA,QAAK,AAAD,EAAU,SAAS","debugId":null}},
    {"offset": {"line": 187, "column": 0}, "map": {"version":3,"sources":["file:///home/hardik/rajashai/app/api/result/history/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { dbConnect } from '@/lib/mongodb';\nimport Round from '@/models/Round';\n\n// helper: parse YYYY-MM and compute month range (IST)\nfunction rangeForMonth(yyyyMM?: string) {\n  const now = new Date();\n  const [Y, M] = yyyyMM?.split('-').map(Number) ?? [now.getFullYear(), now.getMonth() + 1];\n  const start = new Date(Date.UTC(Y, M - 1, 1, 0, 0, 0));\n  const end = new Date(Date.UTC(Y, M, 1, 0, 0, 0)); // exclusive\n  return { start, end };\n}\n\nexport async function GET(req: Request) {\n  const { searchParams } = new URL(req.url);\n  const month = searchParams.get('month') ?? undefined; // '2025-10'\n  const limit = Number(searchParams.get('limit') ?? 0); // optional fallback\n\n  await dbConnect();\n\n  let filter: any = {};\n  if (month) {\n    const { start, end } = rangeForMonth(month);\n    // sessionDate is 'YYYY-MM-DD' local; filter by string bounds\n    const yyyyMM = month;\n    const lo = `${yyyyMM}-01`;\n    const hi = new Date(end).toISOString().slice(0, 10); // first of next month\n    filter.sessionDate = { $gte: lo, $lt: hi };\n  }\n\n  const rounds = await Round\n    .find(filter)\n    .sort({ sessionDate: 1 })   // chronological\n    .select('sessionDate openingPanna closingPanna openingDigit closingDigit jodi status')\n    .lean();\n\n  // Optionally fall back to recent N days if month not provided\n  const data = month || !limit ? rounds : rounds.slice(-limit);\n\n  return NextResponse.json({ items: data });\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AAEA,sDAAsD;AACtD,SAAS,cAAc,MAAe;IACpC,MAAM,MAAM,IAAI;IAChB,MAAM,CAAC,GAAG,EAAE,GAAG,QAAQ,MAAM,KAAK,IAAI,WAAW;QAAC,IAAI,WAAW;QAAI,IAAI,QAAQ,KAAK;KAAE;IACxF,MAAM,QAAQ,IAAI,KAAK,KAAK,GAAG,CAAC,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG;IACnD,MAAM,MAAM,IAAI,KAAK,KAAK,GAAG,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,KAAK,YAAY;IAC9D,OAAO;QAAE;QAAO;IAAI;AACtB;AAEO,eAAe,IAAI,GAAY;IACpC,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,IAAI,GAAG;IACxC,MAAM,QAAQ,aAAa,GAAG,CAAC,YAAY,WAAW,YAAY;IAClE,MAAM,QAAQ,OAAO,aAAa,GAAG,CAAC,YAAY,IAAI,oBAAoB;IAE1E,MAAM,CAAA,GAAA,gHAAA,CAAA,YAAS,AAAD;IAEd,IAAI,SAAc,CAAC;IACnB,IAAI,OAAO;QACT,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,cAAc;QACrC,6DAA6D;QAC7D,MAAM,SAAS;QACf,MAAM,KAAK,GAAG,OAAO,GAAG,CAAC;QACzB,MAAM,KAAK,IAAI,KAAK,KAAK,WAAW,GAAG,KAAK,CAAC,GAAG,KAAK,sBAAsB;QAC3E,OAAO,WAAW,GAAG;YAAE,MAAM;YAAI,KAAK;QAAG;IAC3C;IAEA,MAAM,SAAS,MAAM,iHAAA,CAAA,UAAK,CACvB,IAAI,CAAC,QACL,IAAI,CAAC;QAAE,aAAa;IAAE,GAAK,gBAAgB;KAC3C,MAAM,CAAC,+EACP,IAAI;IAEP,8DAA8D;IAC9D,MAAM,OAAO,SAAS,CAAC,QAAQ,SAAS,OAAO,KAAK,CAAC,CAAC;IAEtD,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;QAAE,OAAO;IAAK;AACzC","debugId":null}}]
}